/*
 * "Hello World" example.
 *
 * This example prints 'Hello from Nios II' to the STDOUT stream. It runs on
 * the Nios II 'standard', 'full_featured', 'fast', and 'low_cost' example
 * designs. It runs with or without the MicroC/OS-II RTOS and requires a STDOUT
 * device in your system's hardware.
 * The memory footprint of this hosted application is ~69 kbytes by default
 * using the standard reference design.
 *
 * For a reduced footprint version of this template, and an explanation of how
 * to reduce the memory footprint for a given application, see the
 * "small_hello_world" template.
 *
 */

#include &lt;system.h&gt;
#include &lt;altera_avalon_pio_regs.h&gt;
#include &lt;alt_types.h&gt;
#include &lt;sys/alt_irq.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

volatile int counter = 0;
volatile int key1_pressed = 0; // Flag to track Key1 press and hold

// Function to increment the counter
void incrementCounter() {
	counter++;
}

// Timer ISR
alt_u32 timer_isr_function(void* context) {
	int* timeCount = (int*) context;

	// Check if Key1 is pressed and held down
	if (key1_pressed) {
	incrementCounter();
	printf("Counter: %i\n",counter);
	}
	return 500; // Set the timer to trigger every 500ms
}


// Button ISR
void key_button_interrupts(void* context, alt_u32 id) {
	int* temp = (int*) context;
	(*temp) = IORD_ALTERA_AVALON_PIO_EDGE_CAP(KEYS_BASE);
	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEYS_BASE, 0);

	if (!((*temp) & 0x01)) {
		// Key0 pressed
		incrementCounter();
		printf("Counter: %i\n",counter);
	}

	if (!((*temp) & 0x02)) {
	// Key1 pressed
	key1_pressed = 1; // Set the Key1 press and hold flag
	} else {

	// Key1 released
	key1_pressed = 0; // Clear the flag
	}
}

int main(void) {
	alt_alarm timer;
	int timeCountMain = 0;
	void* timerContext = (void*) &amp;timeCountMain;

	alt_alarm_start(&timer, 500, timer_isr_function, timerContext);

	int counterValue = 0;
	void* context_going_to_be_passed = (void*) &amp;counterValue;

	IOWR_ALTERA_AVALON_PIO_EDGE_CAP(KEYS_BASE, 0);
	IOWR_ALTERA_AVALON_PIO_IRQ_MASK(KEYS_BASE, 0x3);

	alt_irq_register(KEYS_IRQ, context_going_to_be_passed, key_button_interrupts);

	// // Function to send a command to the LCD
	// void sendCommand(unsigned char command) {
	// IOWR(LCD_RS, 0, 0); // Set RS to 0 for command mode
	// IOWR(LCD_RW, 0, 0); // Set RW to 0 for write mode
	// IOWR(LCD_DATA, 0, command); // Send the command on the data bus

	// // Pulse the enable signal (E) to latch the command
	// IOWR(LCD_EN, 0, 1);
	// usleep(LCD_DELAY_US);

	// IOWR(LCD_EN, 0, 0);
	// usleep(LCD_DELAY_US);
	// }

	// // Function to send data to the LCD
	// void sendData(unsigned char data) {
	// IOWR(LCD_RS, 0, 1); // Set RS to 1 for data mode
	// IOWR(LCD_RW, 0, 0); // Set RW to 0 for write mode
	// IOWR(LCD_DATA, 0, data); // Send the data on the data bus

	// // Pulse the enable signal (E) to latch the data
	// IOWR(LCD_EN, 0, 1);
	// usleep(LCD_DELAY_US);
	// IOWR(LCD_EN, 0, 0);
	// usleep(LCD_DELAY_US);
	// }

	while (1);

	return 0;
}
